{"$message_type":"diagnostic","message":"invalid reference to argument at index 1","code":null,"level":"error","spans":[{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2210,"byte_end":2213,"line_start":74,"line_end":74,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            \"mul {1}\",","highlight_start":18,"highlight_end":21}],"label":"from here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2302,"byte_end":2313,"line_start":76,"line_end":76,"column_start":13,"column_end":24,"is_primary":false,"text":[{"text":"            in(\"rdx\") b,                // b in rdx, will be overwritten","highlight_start":13,"highlight_end":24}],"label":"explicit register argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"no positional arguments were given","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"explicit register arguments cannot be used in the asm template","code":null,"level":"note","spans":[{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2302,"byte_end":2313,"line_start":76,"line_end":76,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"            in(\"rdx\") b,                // b in rdx, will be overwritten","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use the register name directly in the assembly code","code":null,"level":"help","spans":[{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2302,"byte_end":2313,"line_start":76,"line_end":76,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"            in(\"rdx\") b,                // b in rdx, will be overwritten","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\assembly\\mul_asm.rs:74:18: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m: invalid reference to argument at index 1: from here\u001b[0m\n"}
{"$message_type":"diagnostic","message":"environment variable `SLINT_INCLUDE_GENERATED` not defined at compile time","code":null,"level":"error","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\slint-1.14.1\\lib.rs","byte_start":15803,"byte_end":15834,"line_start":360,"line_end":360,"column_start":18,"column_end":49,"is_primary":true,"text":[{"text":"        include!(env!(\"SLINT_INCLUDE_GENERATED\"));","highlight_start":18,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\slint-1.14.1\\lib.rs","byte_start":15803,"byte_end":15834,"line_start":360,"line_end":360,"column_start":18,"column_end":49,"is_primary":false,"text":[{"text":"        include!(env!(\"SLINT_INCLUDE_GENERATED\"));","highlight_start":18,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\ui\\app.rs","byte_start":271,"byte_end":296,"line_start":11,"line_end":11,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"slint::include_modules!();","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"slint::include_modules!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\slint-1.14.1\\lib.rs","byte_start":15743,"byte_end":15771,"line_start":358,"line_end":358,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! include_modules {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"env!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":37318,"byte_end":37334,"line_start":1064,"line_end":1064,"column_start":5,"column_end":21,"is_primary":false,"text":[{"text":"    macro_rules! env {","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"use `std::env::var(\"SLINT_INCLUDE_GENERATED\")` to read the variable at run time","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\ui\\app.rs:11:1: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m: environment variable `SLINT_INCLUDE_GENERATED` not defined at compile time\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unresolved import `bigint::BigInt`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":167,"byte_end":181,"line_start":10,"line_end":10,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"pub use bigint::BigInt;","highlight_start":9,"highlight_end":23}],"label":"no `BigInt` in `rsa::bigint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":175,"byte_end":181,"line_start":10,"line_end":10,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"pub use bigint::BigInt;","highlight_start":17,"highlight_end":23}],"label":null,"suggested_replacement":"BigUint","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct instead","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":167,"byte_end":181,"line_start":10,"line_end":10,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"pub use bigint::BigInt;","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":"num_bigint::BigInt","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\mod.rs:10:9: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m: unresolved import `bigint::BigInt`: no `BigInt` in `rsa::bigint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unresolved import `encrypt::encrypt_data`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":268,"byte_end":289,"line_start":12,"line_end":12,"column_start":9,"column_end":30,"is_primary":true,"text":[{"text":"pub use encrypt::encrypt_data;","highlight_start":9,"highlight_end":30}],"label":"no `encrypt_data` in `rsa::encrypt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":277,"byte_end":289,"line_start":12,"line_end":12,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"pub use encrypt::encrypt_data;","highlight_start":18,"highlight_end":30}],"label":null,"suggested_replacement":"encrypt_oaep","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\mod.rs:12:9: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m: unresolved import `encrypt::encrypt_data`: no `encrypt_data` in `rsa::encrypt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unresolved import `decrypt::decrypt_data`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":299,"byte_end":320,"line_start":13,"line_end":13,"column_start":9,"column_end":30,"is_primary":true,"text":[{"text":"pub use decrypt::decrypt_data;","highlight_start":9,"highlight_end":30}],"label":"no `decrypt_data` in `rsa::decrypt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\mod.rs","byte_start":308,"byte_end":320,"line_start":13,"line_end":13,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"pub use decrypt::decrypt_data;","highlight_start":18,"highlight_end":30}],"label":null,"suggested_replacement":"decrypt_crt","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\mod.rs:13:9: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m: unresolved import `decrypt::decrypt_data`: no `decrypt_data` in `rsa::decrypt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unresolved import `slint::WeakComponent`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src\\ui\\app.rs","byte_start":128,"byte_end":141,"line_start":4,"line_end":4,"column_start":30,"column_end":43,"is_primary":true,"text":[{"text":"use slint::{ComponentHandle, WeakComponent};","highlight_start":30,"highlight_end":43}],"label":"no `WeakComponent` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\ui\\app.rs:4:30: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m: unresolved import `slint::WeakComponent`: no `WeakComponent` in the root\u001b[0m\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `PaddedData` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":1015,"byte_end":1025,"line_start":32,"line_end":32,"column_start":18,"column_end":28,"is_primary":true,"text":[{"text":"    let padded = PaddedData {","highlight_start":18,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":113,"byte_end":113,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use super::bigint::{RsaBigInt, from_bytes, mod_pow};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::rsa::padding::PaddedData;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:32:18: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0422]\u001b[0m\u001b[0m: cannot find struct, variant or union type `PaddedData` in this scope: not found in this scope\u001b[0m\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `PlatformStub` in module `slint::platform`","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src\\ui\\app.rs","byte_start":957,"byte_end":969,"line_start":38,"line_end":38,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"    let platform = slint::platform::PlatformStub {};","highlight_start":37,"highlight_end":49}],"label":"not found in `slint::platform`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\ui\\app.rs:38:37: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0422]\u001b[0m\u001b[0m: cannot find struct, variant or union type `PlatformStub` in module `slint::platform`: not found in `slint::platform`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `ToBigUint`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":126,"byte_end":135,"line_start":4,"line_end":4,"column_start":39,"column_end":48,"is_primary":true,"text":[{"text":"use num_bigint::{BigUint, RandBigInt, ToBigUint};","highlight_start":39,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":124,"byte_end":135,"line_start":4,"line_end":4,"column_start":37,"column_end":48,"is_primary":true,"text":[{"text":"use num_bigint::{BigUint, RandBigInt, ToBigUint};","highlight_start":37,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\bigint.rs:4:39: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `ToBigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `Pow`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":192,"byte_end":195,"line_start":6,"line_end":6,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"use num_traits::{One, Zero, Pow};","highlight_start":29,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":190,"byte_end":195,"line_start":6,"line_end":6,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"use num_traits::{One, Zero, Pow};","highlight_start":27,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\bigint.rs:6:29: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `Pow`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `std::fmt`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":224,"byte_end":232,"line_start":8,"line_end":8,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\bigint.rs","byte_start":220,"byte_end":234,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\bigint.rs:8:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `std::fmt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused imports: `is_probable_prime`, `lcm`, `mod_pow`, and `random_biguint`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":146,"byte_end":163,"line_start":5,"line_end":5,"column_start":39,"column_end":56,"is_primary":true,"text":[{"text":"    RsaBigInt, from_u64, mod_inverse, is_probable_prime, random_prime,","highlight_start":39,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":183,"byte_end":190,"line_start":6,"line_end":6,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    mod_pow, gcd, lcm, random_biguint,","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":197,"byte_end":200,"line_start":6,"line_end":6,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"    mod_pow, gcd, lcm, random_biguint,","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":202,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"    mod_pow, gcd, lcm, random_biguint,","highlight_start":24,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":144,"byte_end":163,"line_start":5,"line_end":5,"column_start":37,"column_end":56,"is_primary":true,"text":[{"text":"    RsaBigInt, from_u64, mod_inverse, is_probable_prime, random_prime,","highlight_start":37,"highlight_end":56}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":177,"byte_end":190,"line_start":5,"line_end":6,"column_start":70,"column_end":12,"is_primary":true,"text":[{"text":"    RsaBigInt, from_u64, mod_inverse, is_probable_prime, random_prime,","highlight_start":70,"highlight_end":71},{"text":"    mod_pow, gcd, lcm, random_biguint,","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":195,"byte_end":216,"line_start":6,"line_end":6,"column_start":17,"column_end":38,"is_primary":true,"text":[{"text":"    mod_pow, gcd, lcm, random_biguint,","highlight_start":17,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:5:39: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused imports: `is_probable_prime`, `lcm`, `mod_pow`, and `random_biguint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `num_traits::One`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":225,"byte_end":240,"line_start":8,"line_end":8,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use num_traits::One;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":221,"byte_end":242,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use num_traits::One;","highlight_start":1,"highlight_end":21},{"text":"use std::fmt;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:8:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `num_traits::One`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `std::fmt`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":246,"byte_end":254,"line_start":9,"line_end":9,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":242,"byte_end":256,"line_start":9,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":1,"highlight_end":14},{"text":"use serde::{Serialize, Deserialize};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:9:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `std::fmt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `RsaBigInt`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":108,"byte_end":117,"line_start":4,"line_end":4,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"use super::bigint::{RsaBigInt, from_bytes, to_bytes, mod_pow};","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":108,"byte_end":119,"line_start":4,"line_end":4,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"use super::bigint::{RsaBigInt, from_bytes, to_bytes, mod_pow};","highlight_start":21,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\encrypt.rs:4:21: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `RsaBigInt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `PaddedData`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":220,"byte_end":230,"line_start":6,"line_end":6,"column_start":37,"column_end":47,"is_primary":true,"text":[{"text":"use super::padding::{pad_pkcs1_v15, PaddedData};","highlight_start":37,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":218,"byte_end":230,"line_start":6,"line_end":6,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"use super::padding::{pad_pkcs1_v15, PaddedData};","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\rsa\\encrypt.rs","byte_start":204,"byte_end":205,"line_start":6,"line_end":6,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"use super::padding::{pad_pkcs1_v15, PaddedData};","highlight_start":21,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\rsa\\encrypt.rs","byte_start":230,"byte_end":231,"line_start":6,"line_end":6,"column_start":47,"column_end":48,"is_primary":true,"text":[{"text":"use super::padding::{pad_pkcs1_v15, PaddedData};","highlight_start":47,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\encrypt.rs:6:37: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `PaddedData`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `num_traits::One`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":241,"byte_end":256,"line_start":7,"line_end":7,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use num_traits::One;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":237,"byte_end":258,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use num_traits::One;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:7:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `num_traits::One`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused import: `std::fmt`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":96,"byte_end":104,"line_start":4,"line_end":4,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":92,"byte_end":106,"line_start":4,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:4:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused import: `std::fmt`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unused imports: `SeekFrom` and `Seek`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":178,"byte_end":182,"line_start":5,"line_end":5,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"use std::io::{self, Read, Write, Seek, SeekFrom};","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":184,"byte_end":192,"line_start":5,"line_end":5,"column_start":40,"column_end":48,"is_primary":true,"text":[{"text":"use std::io::{self, Read, Write, Seek, SeekFrom};","highlight_start":40,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":176,"byte_end":192,"line_start":5,"line_end":5,"column_start":32,"column_end":48,"is_primary":true,"text":[{"text":"use std::io::{self, Read, Write, Seek, SeekFrom};","highlight_start":32,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\util\\file_ops.rs:5:34: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unused imports: `SeekFrom` and `Seek`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":347,"byte_end":356,"line_start":13,"line_end":13,"column_start":35,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":35,"highlight_end":44}],"label":"the trait `Serialize` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\keygen.rs","byte_start":347,"byte_end":356,"line_start":13,"line_end":13,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\rsa\\keygen.rs","byte_start":402,"byte_end":405,"line_start":15,"line_end":15,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub n: RsaBigInt,  // Modulus","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 163 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:13:35: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Serialize` is not satisfied: the trait `Serialize` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":409,"byte_end":418,"line_start":15,"line_end":15,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub n: RsaBigInt,  // Modulus","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:15:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":443,"byte_end":452,"line_start":16,"line_end":16,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub e: RsaBigInt,  // Public exponent","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:16:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":409,"byte_end":418,"line_start":15,"line_end":15,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub n: RsaBigInt,  // Modulus","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:15:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":443,"byte_end":452,"line_start":16,"line_end":16,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub e: RsaBigInt,  // Public exponent","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:16:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":358,"byte_end":369,"line_start":13,"line_end":13,"column_start":46,"column_end":57,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":46,"highlight_end":57}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\keygen.rs","byte_start":358,"byte_end":369,"line_start":13,"line_end":13,"column_start":46,"column_end":57,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":46,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:13:46: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":531,"byte_end":540,"line_start":20,"line_end":20,"column_start":35,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":35,"highlight_end":44}],"label":"the trait `Serialize` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\keygen.rs","byte_start":531,"byte_end":540,"line_start":20,"line_end":20,"column_start":35,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":35,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\rsa\\keygen.rs","byte_start":587,"byte_end":590,"line_start":22,"line_end":22,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub n: RsaBigInt,      // Modulus (same as public)","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 163 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:20:35: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Serialize` is not satisfied: the trait `Serialize` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":594,"byte_end":603,"line_start":22,"line_end":22,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub n: RsaBigInt,      // Modulus (same as public)","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:22:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":649,"byte_end":658,"line_start":23,"line_end":23,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub d: RsaBigInt,      // Private exponent","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:23:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":696,"byte_end":705,"line_start":24,"line_end":24,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub p: RsaBigInt,      // First prime factor","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:24:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":745,"byte_end":754,"line_start":25,"line_end":25,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub q: RsaBigInt,      // Second prime factor","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:25:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":846,"byte_end":855,"line_start":27,"line_end":27,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    pub d_p: RsaBigInt,    // d mod (p-1)","highlight_start":14,"highlight_end":23}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:27:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":888,"byte_end":897,"line_start":28,"line_end":28,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    pub d_q: RsaBigInt,    // d mod (q-1)","highlight_start":14,"highlight_end":23}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:28:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":932,"byte_end":941,"line_start":29,"line_end":29,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"    pub q_inv: RsaBigInt,  // q^(-1) mod p","highlight_start":16,"highlight_end":25}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:29:16: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":594,"byte_end":603,"line_start":22,"line_end":22,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub n: RsaBigInt,      // Modulus (same as public)","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:22:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":649,"byte_end":658,"line_start":23,"line_end":23,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub d: RsaBigInt,      // Private exponent","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:23:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":696,"byte_end":705,"line_start":24,"line_end":24,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub p: RsaBigInt,      // First prime factor","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:24:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":745,"byte_end":754,"line_start":25,"line_end":25,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub q: RsaBigInt,      // Second prime factor","highlight_start":12,"highlight_end":21}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:25:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":846,"byte_end":855,"line_start":27,"line_end":27,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    pub d_p: RsaBigInt,    // d mod (p-1)","highlight_start":14,"highlight_end":23}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:27:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":888,"byte_end":897,"line_start":28,"line_end":28,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    pub d_q: RsaBigInt,    // d mod (q-1)","highlight_start":14,"highlight_end":23}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:28:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":932,"byte_end":941,"line_start":29,"line_end":29,"column_start":16,"column_end":25,"is_primary":true,"text":[{"text":"    pub q_inv: RsaBigInt,  // q^(-1) mod p","highlight_start":16,"highlight_end":25}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:29:16: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":542,"byte_end":553,"line_start":20,"line_end":20,"column_start":46,"column_end":57,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":46,"highlight_end":57}],"label":"the trait `Deserialize<'_>` is not implemented for `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\keygen.rs","byte_start":542,"byte_end":553,"line_start":20,"line_end":20,"column_start":46,"column_end":57,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]","highlight_start":46,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `BigUint` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 178 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:20:46: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `BigUint: serde::Deserialize<'de>` is not satisfied: the trait `Deserialize<'_>` is not implemented for `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":2989,"byte_end":2990,"line_start":99,"line_end":99,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"        return generate_keypair(bit_length, e);","highlight_start":45,"highlight_end":46}],"label":"expected `u64`, found `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":2960,"byte_end":2976,"line_start":99,"line_end":99,"column_start":16,"column_end":32,"is_primary":false,"text":[{"text":"        return generate_keypair(bit_length, e);","highlight_start":16,"highlight_end":32}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src\\rsa\\keygen.rs","byte_start":2448,"byte_end":2454,"line_start":82,"line_end":82,"column_start":42,"column_end":48,"is_primary":false,"text":[{"text":"pub fn generate_keypair(bit_length: u32, e: u64) -> Result<RsaKeyPair, String> {","highlight_start":42,"highlight_end":48}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\keygen.rs","byte_start":2414,"byte_end":2430,"line_start":82,"line_end":82,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"pub fn generate_keypair(bit_length: u32, e: u64) -> Result<RsaKeyPair, String> {","highlight_start":8,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\keygen.rs:99:45: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `u64`, found `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":838,"byte_end":847,"line_start":25,"line_end":25,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"    let mut result = vec![0u8; key_bytes];","highlight_start":32,"highlight_end":41}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1540,"byte_end":1562,"line_start":47,"line_end":47,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":9,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\encrypt.rs","byte_start":828,"byte_end":848,"line_start":25,"line_end":25,"column_start":22,"column_end":42,"is_primary":false,"text":[{"text":"    let mut result = vec![0u8; key_bytes];","highlight_start":22,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1431,"byte_end":1447,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs","byte_start":129561,"byte_end":129570,"line_start":3464,"line_end":3464,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":847,"byte_end":847,"line_start":25,"line_end":25,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"    let mut result = vec![0u8; key_bytes];","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\encrypt.rs:25:32: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":891,"byte_end":907,"line_start":26,"line_end":26,"column_start":42,"column_end":58,"is_primary":true,"text":[{"text":"    let start = key_bytes.saturating_sub(ciphertext.len());","highlight_start":42,"highlight_end":58}],"label":"expected `u32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\encrypt.rs","byte_start":876,"byte_end":890,"line_start":26,"line_end":26,"column_start":27,"column_end":41,"is_primary":false,"text":[{"text":"    let start = key_bytes.saturating_sub(ciphertext.len());","highlight_start":27,"highlight_end":41}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\num\\uint_macros.rs","byte_start":88787,"byte_end":88801,"line_start":2191,"line_end":2191,"column_start":22,"column_end":36,"is_primary":true,"text":[{"text":"        pub const fn saturating_sub(self, rhs: Self) -> Self {","highlight_start":22,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\num\\mod.rs","byte_start":37509,"byte_end":38127,"line_start":1134,"line_end":1155,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    uint_impl! {","highlight_start":5,"highlight_end":1},{"text":"        Self = u32,","highlight_start":1,"highlight_end":1},{"text":"        ActualT = u32,","highlight_start":1,"highlight_end":1},{"text":"        SignedT = i32,","highlight_start":1,"highlight_end":1},{"text":"        BITS = 32,","highlight_start":1,"highlight_end":1},{"text":"        BITS_MINUS_ONE = 31,","highlight_start":1,"highlight_end":1},{"text":"        MAX = 4294967295,","highlight_start":1,"highlight_end":1},{"text":"        rot = 8,","highlight_start":1,"highlight_end":1},{"text":"        rot_op = \"0x10000b3\",","highlight_start":1,"highlight_end":1},{"text":"        rot_result = \"0xb301\",","highlight_start":1,"highlight_end":1},{"text":"        fsh_op = \"0x2fe78e45\",","highlight_start":1,"highlight_end":1},{"text":"        fshl_result = \"0xb32f\",","highlight_start":1,"highlight_end":1},{"text":"        fshr_result = \"0xb32fe78e\",","highlight_start":1,"highlight_end":1},{"text":"        swap_op = \"0x12345678\",","highlight_start":1,"highlight_end":1},{"text":"        swapped = \"0x78563412\",","highlight_start":1,"highlight_end":1},{"text":"        reversed = \"0x1e6a2c48\",","highlight_start":1,"highlight_end":1},{"text":"        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",","highlight_start":1,"highlight_end":1},{"text":"        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",","highlight_start":1,"highlight_end":1},{"text":"        to_xe_bytes_doc = \"\",","highlight_start":1,"highlight_end":1},{"text":"        from_xe_bytes_doc = \"\",","highlight_start":1,"highlight_end":1},{"text":"        bound_condition = \"\",","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"uint_impl!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\num\\uint_macros.rs","byte_start":0,"byte_end":22,"line_start":1,"line_end":1,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! uint_impl {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"you can convert a `usize` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":907,"byte_end":907,"line_start":26,"line_end":26,"column_start":58,"column_end":58,"is_primary":true,"text":[{"text":"    let start = key_bytes.saturating_sub(ciphertext.len());","highlight_start":58,"highlight_end":58}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\encrypt.rs:26:42: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `u32`, found `usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the type `[u8]` cannot be indexed by `std::ops::RangeFrom<u32>`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\encrypt.rs","byte_start":921,"byte_end":928,"line_start":27,"line_end":27,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    result[start..].copy_from_slice(&ciphertext);","highlight_start":12,"highlight_end":19}],"label":"slice indices are of type `usize` or ranges of `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `SliceIndex<[u8]>` is not implemented for `std::ops::RangeFrom<u32>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `SliceIndex<T>`:\n  `std::ops::RangeFrom<usize>` implements `SliceIndex<ByteStr>`\n  `std::ops::RangeFrom<usize>` implements `SliceIndex<[T]>`\n  `std::ops::RangeFrom<usize>` implements `SliceIndex<str>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<u8>` to implement `Index<std::ops::RangeFrom<u32>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\encrypt.rs:27:12: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the type `[u8]` cannot be indexed by `std::ops::RangeFrom<u32>`: slice indices are of type `usize` or ranges of `usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":632,"byte_end":641,"line_start":17,"line_end":17,"column_start":28,"column_end":37,"is_primary":true,"text":[{"text":"    if ciphertext.len() != key_bytes {","highlight_start":28,"highlight_end":37}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:17:28: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"can't compare `usize` with `u32`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":629,"byte_end":631,"line_start":17,"line_end":17,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"    if ciphertext.len() != key_bytes {","highlight_start":25,"highlight_end":27}],"label":"no implementation for `usize == u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `PartialEq<u32>` is not implemented for `usize`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `PartialEq<Rhs>`:\n  `usize` implements `PartialEq<serde_json::Value>`\n  `usize` implements `PartialEq`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:17:25: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: can't compare `usize` with `u32`: no implementation for `usize == u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be applied to values that implement `Try`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":1444,"byte_end":1473,"line_start":47,"line_end":47,"column_start":14,"column_end":43,"is_primary":true,"text":[{"text":"    let m1 = mod_pow(c, &key.d_p, &key.p)?;","highlight_start":14,"highlight_end":43}],"label":"the `?` operator cannot be applied to type `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\decrypt.rs","byte_start":1444,"byte_end":1473,"line_start":47,"line_end":47,"column_start":14,"column_end":43,"is_primary":false,"text":[{"text":"    let m1 = mod_pow(c, &key.d_p, &key.p)?;","highlight_start":14,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Try` is not implemented for `BigUint`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:47:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the `?` operator can only be applied to values that implement `Try`: the `?` operator cannot be applied to type `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be applied to values that implement `Try`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\decrypt.rs","byte_start":1513,"byte_end":1542,"line_start":50,"line_end":50,"column_start":14,"column_end":43,"is_primary":true,"text":[{"text":"    let m2 = mod_pow(c, &key.d_q, &key.q)?;","highlight_start":14,"highlight_end":43}],"label":"the `?` operator cannot be applied to type `BigUint`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\decrypt.rs","byte_start":1513,"byte_end":1542,"line_start":50,"line_end":50,"column_start":14,"column_end":43,"is_primary":false,"text":[{"text":"    let m2 = mod_pow(c, &key.d_q, &key.q)?;","highlight_start":14,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Try` is not implemented for `BigUint`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\decrypt.rs:50:14: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the `?` operator can only be applied to values that implement `Try`: the `?` operator cannot be applied to type `BigUint`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":768,"byte_end":792,"line_start":24,"line_end":24,"column_start":21,"column_end":45,"is_primary":true,"text":[{"text":"    if data.len() > key_size - min_data_size {","highlight_start":21,"highlight_end":45}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\padding.rs","byte_start":755,"byte_end":765,"line_start":24,"line_end":24,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    if data.len() > key_size - min_data_size {","highlight_start":8,"highlight_end":18}],"label":"expected because this is `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":768,"byte_end":768,"line_start":24,"line_end":24,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"    if data.len() > key_size - min_data_size {","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\rsa\\padding.rs","byte_start":792,"byte_end":792,"line_start":24,"line_end":24,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"    if data.len() > key_size - min_data_size {","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:24:21: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1080,"byte_end":1090,"line_start":34,"line_end":34,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"    let ps_len = key_size - data.len() - 3; // 2 (00 02) + 1 (00) + data","highlight_start":29,"highlight_end":39}],"label":"expected `u32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\rsa\\padding.rs:34:29: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `u32`, found `usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"cannot subtract `usize` from `u32`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1078,"byte_end":1079,"line_start":34,"line_end":34,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"    let ps_len = key_size - data.len() - 3; // 2 (00 02) + 1 (00) + data","highlight_start":27,"highlight_end":28}],"label":"no implementation for `u32 - usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sub<usize>` is not implemented for `u32`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sub<Rhs>`:\n  `&u32` implements `Sub<&BigInt>`\n  `&u32` implements `Sub<&BigUint>`\n  `&u32` implements `Sub<BigInt>`\n  `&u32` implements `Sub<BigUint>`\n  `&u32` implements `Sub<u32>`\n  `&u32` implements `Sub`\n  `u32` implements `Sub<&BigInt>`\n  `u32` implements `Sub<&BigUint>`\nand 5 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:34:27: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: cannot subtract `usize` from `u32`: no implementation for `u32 - usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1255,"byte_end":1261,"line_start":39,"line_end":39,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"    let mut padding = vec![0u8; ps_len];","highlight_start":33,"highlight_end":39}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1540,"byte_end":1562,"line_start":47,"line_end":47,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":9,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\padding.rs","byte_start":1245,"byte_end":1262,"line_start":39,"line_end":39,"column_start":23,"column_end":40,"is_primary":false,"text":[{"text":"    let mut padding = vec![0u8; ps_len];","highlight_start":23,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1431,"byte_end":1447,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs","byte_start":129561,"byte_end":129570,"line_start":3464,"line_end":3464,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1261,"byte_end":1261,"line_start":39,"line_end":39,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"    let mut padding = vec![0u8; ps_len];","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:39:33: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1549,"byte_end":1557,"line_start":49,"line_end":49,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"    let mut result = Vec::with_capacity(key_size);","highlight_start":41,"highlight_end":49}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\padding.rs","byte_start":1530,"byte_end":1548,"line_start":49,"line_end":49,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"    let mut result = Vec::with_capacity(key_size);","highlight_start":22,"highlight_end":40}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs","byte_start":18595,"byte_end":18608,"line_start":519,"line_end":519,"column_start":12,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn with_capacity(capacity: usize) -> Self {","highlight_start":12,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1557,"byte_end":1557,"line_start":49,"line_end":49,"column_start":49,"column_end":49,"is_primary":true,"text":[{"text":"    let mut result = Vec::with_capacity(key_size);","highlight_start":49,"highlight_end":49}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:49:41: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1768,"byte_end":1776,"line_start":57,"line_end":57,"column_start":23,"column_end":31,"is_primary":true,"text":[{"text":"    if result.len() < key_size {","highlight_start":23,"highlight_end":31}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\rsa\\padding.rs","byte_start":1753,"byte_end":1765,"line_start":57,"line_end":57,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    if result.len() < key_size {","highlight_start":8,"highlight_end":20}],"label":"expected because this is `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1776,"byte_end":1776,"line_start":57,"line_end":57,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"    if result.len() < key_size {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:57:23: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1817,"byte_end":1829,"line_start":58,"line_end":58,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"        let zeros_needed = key_size - result.len();","highlight_start":39,"highlight_end":51}],"label":"expected `u32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\rsa\\padding.rs:58:39: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `u32`, found `usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"cannot subtract `usize` from `u32`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1815,"byte_end":1816,"line_start":58,"line_end":58,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"        let zeros_needed = key_size - result.len();","highlight_start":37,"highlight_end":38}],"label":"no implementation for `u32 - usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sub<usize>` is not implemented for `u32`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sub<Rhs>`:\n  `&u32` implements `Sub<&BigInt>`\n  `&u32` implements `Sub<&BigUint>`\n  `&u32` implements `Sub<BigInt>`\n  `&u32` implements `Sub<BigUint>`\n  `&u32` implements `Sub<u32>`\n  `&u32` implements `Sub`\n  `u32` implements `Sub<&BigInt>`\n  `u32` implements `Sub<&BigUint>`\nand 5 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:58:37: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: cannot subtract `usize` from `u32`: no implementation for `u32 - usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1866,"byte_end":1878,"line_start":59,"line_end":59,"column_start":36,"column_end":48,"is_primary":true,"text":[{"text":"        let mut padded = vec![0u8; zeros_needed];","highlight_start":36,"highlight_end":48}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1540,"byte_end":1562,"line_start":47,"line_end":47,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":9,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\rsa\\padding.rs","byte_start":1856,"byte_end":1879,"line_start":59,"line_end":59,"column_start":26,"column_end":49,"is_primary":false,"text":[{"text":"        let mut padded = vec![0u8; zeros_needed];","highlight_start":26,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\macros.rs","byte_start":1431,"byte_end":1447,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\alloc\\src\\vec\\mod.rs","byte_start":129561,"byte_end":129570,"line_start":3464,"line_end":3464,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":1878,"byte_end":1878,"line_start":59,"line_end":59,"column_start":48,"column_end":48,"is_primary":true,"text":[{"text":"        let mut padded = vec![0u8; zeros_needed];","highlight_start":48,"highlight_end":48}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\rsa\\padding.rs:59:36: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\rsa\\padding.rs","byte_start":2021,"byte_end":2029,"line_start":66,"line_end":66,"column_start":24,"column_end":32,"is_primary":true,"text":[{"text":"        expected_size: key_size,","highlight_start":24,"highlight_end":32}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\rsa\\padding.rs:66:24: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `usize`, found `u32`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"the trait bound `dyn Fn(f64) + Send: Clone` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":1017,"byte_end":1071,"line_start":38,"line_end":38,"column_start":5,"column_end":59,"is_primary":true,"text":[{"text":"    pub progress_callback: Option<Box<dyn Fn(f64) + Send>>,","highlight_start":5,"highlight_end":59}],"label":"the trait `Clone` is not implemented for `dyn Fn(f64) + Send`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\util\\file_ops.rs","byte_start":947,"byte_end":952,"line_start":35,"line_end":35,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Clone, Debug)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `Box<dyn Fn(f64) + Send>` to implement `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Box<dyn Fn(f64) + Send>>` to implement `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use parentheses to call this trait object","code":null,"level":"help","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":1071,"byte_end":1071,"line_start":38,"line_end":38,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"    pub progress_callback: Option<Box<dyn Fn(f64) + Send>>,","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":"(/* f64 */)","suggestion_applicability":"HasPlaceholders","expansion":{"span":{"file_name":"src\\util\\file_ops.rs","byte_start":947,"byte_end":952,"line_start":35,"line_end":35,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Clone, Debug)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\util\\file_ops.rs:38:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: the trait bound `dyn Fn(f64) + Send: Clone` is not satisfied: the trait `Clone` is not implemented for `dyn Fn(f64) + Send`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"`(dyn Fn(f64) + Send + 'static)` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":1017,"byte_end":1071,"line_start":38,"line_end":38,"column_start":5,"column_end":59,"is_primary":true,"text":[{"text":"    pub progress_callback: Option<Box<dyn Fn(f64) + Send>>,","highlight_start":5,"highlight_end":59}],"label":"the trait `Debug` is not implemented for `(dyn Fn(f64) + Send + 'static)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\util\\file_ops.rs","byte_start":954,"byte_end":959,"line_start":35,"line_end":35,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"#[derive(Clone, Debug)]","highlight_start":17,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34298,"byte_end":34313,"line_start":912,"line_end":912,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0msrc\\util\\file_ops.rs:38:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: `(dyn Fn(f64) + Send + 'static)` doesn't implement `Debug`: the trait `Debug` is not implemented for `(dyn Fn(f64) + Send + 'static)`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `FileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":2910,"byte_end":2926,"line_start":116,"line_end":116,"column_start":25,"column_end":41,"is_primary":false,"text":[{"text":"        let encrypted = encrypt_fn(data)?;","highlight_start":25,"highlight_end":41}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":2181,"byte_end":2196,"line_start":90,"line_end":90,"column_start":6,"column_end":21,"is_primary":false,"text":[{"text":") -> FileResult<u64>","highlight_start":6,"highlight_end":21}],"label":"expected `FileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":2926,"byte_end":2927,"line_start":116,"line_end":116,"column_start":41,"column_end":42,"is_primary":true,"text":[{"text":"        let encrypted = encrypt_fn(data)?;","highlight_start":41,"highlight_end":42}],"label":"the trait `From<std::string::String>` is not implemented for `FileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\util\\file_ops.rs","byte_start":2926,"byte_end":2927,"line_start":116,"line_end":116,"column_start":41,"column_end":42,"is_primary":false,"text":[{"text":"        let encrypted = encrypt_fn(data)?;","highlight_start":41,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`FileError` needs to implement `From<std::string::String>`","code":null,"level":"note","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":315,"byte_end":333,"line_start":11,"line_end":11,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub enum FileError {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `From<std::string::String>` is not implemented for `FileError`\nbut trait `From<std::io::Error>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `std::io::Error`, found `std::string::String`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\util\\file_ops.rs:116:41: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: `?` couldn't convert the error to `FileError`: the trait `From<std::string::String>` is not implemented for `FileError`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `FileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":4857,"byte_end":4889,"line_start":183,"line_end":183,"column_start":25,"column_end":57,"is_primary":false,"text":[{"text":"        let decrypted = decrypt_fn(&buffer[..chunk_len])?;","highlight_start":25,"highlight_end":57}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":3803,"byte_end":3818,"line_start":149,"line_end":149,"column_start":6,"column_end":21,"is_primary":false,"text":[{"text":") -> FileResult<u64>","highlight_start":6,"highlight_end":21}],"label":"expected `FileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":4889,"byte_end":4890,"line_start":183,"line_end":183,"column_start":57,"column_end":58,"is_primary":true,"text":[{"text":"        let decrypted = decrypt_fn(&buffer[..chunk_len])?;","highlight_start":57,"highlight_end":58}],"label":"the trait `From<std::string::String>` is not implemented for `FileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\util\\file_ops.rs","byte_start":4889,"byte_end":4890,"line_start":183,"line_end":183,"column_start":57,"column_end":58,"is_primary":false,"text":[{"text":"        let decrypted = decrypt_fn(&buffer[..chunk_len])?;","highlight_start":57,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`FileError` needs to implement `From<std::string::String>`","code":null,"level":"note","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":315,"byte_end":333,"line_start":11,"line_end":11,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub enum FileError {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `From<std::string::String>` is not implemented for `FileError`\nbut trait `From<std::io::Error>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `std::io::Error`, found `std::string::String`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\util\\file_ops.rs:183:57: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: `?` couldn't convert the error to `FileError`: the trait `From<std::string::String>` is not implemented for `FileError`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":5678,"byte_end":5688,"line_start":214,"line_end":214,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    Ok(data.len())","highlight_start":8,"highlight_end":18}],"label":"expected `()`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":5675,"byte_end":5677,"line_start":214,"line_end":214,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    Ok(data.len())","highlight_start":5,"highlight_end":7}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `usize` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src\\util\\file_ops.rs","byte_start":5678,"byte_end":5688,"line_start":214,"line_end":214,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    Ok(data.len())","highlight_start":8,"highlight_end":18}],"label":"this argument influences the type of `Ok`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\util\\file_ops.rs","byte_start":5675,"byte_end":5689,"line_start":214,"line_end":214,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"    Ok(data.len())","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Allen Wang\\.rustup\\toolchains\\stable-x86_64-pc-windows-gnu\\lib/rustlib/src/rust\\library\\core\\src\\result.rs","byte_start":20966,"byte_end":20968,"line_start":554,"line_end":554,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\util\\file_ops.rs:214:8: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `()`, found `usize`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `PlatformError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\ui\\app.rs","byte_start":978,"byte_end":1027,"line_start":39,"line_end":39,"column_start":5,"column_end":54,"is_primary":false,"text":[{"text":"    slint::platform::set_platform(Box::new(platform))?;","highlight_start":5,"highlight_end":54}],"label":"this can't be annotated with `?` because it has type `Result<_, slint::platform::SetPlatformError>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\ui\\app.rs","byte_start":853,"byte_end":885,"line_start":36,"line_end":36,"column_start":24,"column_end":56,"is_primary":false,"text":[{"text":"pub fn create_app() -> Result<(), slint::PlatformError> {","highlight_start":24,"highlight_end":56}],"label":"expected `PlatformError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\ui\\app.rs","byte_start":1027,"byte_end":1028,"line_start":39,"line_end":39,"column_start":54,"column_end":55,"is_primary":true,"text":[{"text":"    slint::platform::set_platform(Box::new(platform))?;","highlight_start":54,"highlight_end":55}],"label":"the trait `From<slint::platform::SetPlatformError>` is not implemented for `PlatformError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\ui\\app.rs","byte_start":1027,"byte_end":1028,"line_start":39,"line_end":39,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    slint::platform::set_platform(Box::new(platform))?;","highlight_start":54,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `PlatformError` implements `From<&str>`\n  `PlatformError` implements `From<Box<dyn StdError + Send + Sync>>`\n  `PlatformError` implements `From<std::string::String>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\ui\\app.rs:39:54: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m: `?` couldn't convert the error to `PlatformError`: the trait `From<slint::platform::SetPlatformError>` is not implemented for `PlatformError`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `AppWindow`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\ui\\app.rs","byte_start":1045,"byte_end":1054,"line_start":41,"line_end":41,"column_start":15,"column_end":24,"is_primary":true,"text":[{"text":"    let app = AppWindow::new()?;","highlight_start":15,"highlight_end":24}],"label":"use of undeclared type `AppWindow`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0msrc\\ui\\app.rs:41:15: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m: failed to resolve: use of undeclared type `AppWindow`: use of undeclared type `AppWindow`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\ui\\app.rs","byte_start":2348,"byte_end":2382,"line_start":78,"line_end":78,"column_start":48,"column_end":82,"is_primary":true,"text":[{"text":"                        state.status_message = \"Key pair generated successfully!\";","highlight_start":48,"highlight_end":82}],"label":"expected `String`, found `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\ui\\app.rs","byte_start":2325,"byte_end":2345,"line_start":78,"line_end":78,"column_start":25,"column_end":45,"is_primary":false,"text":[{"text":"                        state.status_message = \"Key pair generated successfully!\";","highlight_start":25,"highlight_end":45}],"label":"expected due to the type of this binding","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try using a conversion method","code":null,"level":"help","spans":[{"file_name":"src\\ui\\app.rs","byte_start":2382,"byte_end":2382,"line_start":78,"line_end":78,"column_start":82,"column_end":82,"is_primary":true,"text":[{"text":"                        state.status_message = \"Key pair generated successfully!\";","highlight_start":82,"highlight_end":82}],"label":null,"suggested_replacement":".to_string()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\ui\\app.rs:78:48: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m: mismatched types: expected `String`, found `&str`\u001b[0m\n"}
{"$message_type":"diagnostic","message":"partially assigned binding `result` isn't fully initialized","code":{"code":"E0381","explanation":"It is not allowed to use or capture an uninitialized variable.\n\nErroneous code example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly-uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2105,"byte_end":2415,"line_start":72,"line_end":78,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        std::arch::asm!(","highlight_start":9,"highlight_end":25},{"text":"            // Multiply using mul (produces 128-bit result in rdx:rax)","highlight_start":1,"highlight_end":71},{"text":"            \"mul {1}\",","highlight_start":1,"highlight_end":23},{"text":"            inout(\"rax\") a => result.1,  // low part in rax, a in operand","highlight_start":1,"highlight_end":74},{"text":"            in(\"rdx\") b,                // b in rdx, will be overwritten","highlight_start":1,"highlight_end":73},{"text":"            options(pure, nomem, nostack),","highlight_start":1,"highlight_end":43},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":"`result` partially assigned here but it isn't fully initialized","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\assembly\\mul_asm.rs","byte_start":2063,"byte_end":2069,"line_start":69,"line_end":69,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"    let result: (u64, u64);","highlight_start":9,"highlight_end":15}],"label":"binding declared here but left uninitialized","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"partial initialization isn't supported, fully initialize the binding with a default value and mutate it, or use `std::mem::MaybeUninit`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\assembly\\mul_asm.rs:72:9: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0381]\u001b[0m\u001b[0m: partially assigned binding `result` isn't fully initialized: `result` partially assigned here but it isn't fully initialized\u001b[0m\n"}
{"$message_type":"diagnostic","message":"aborting due to 57 previous errors; 11 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m: aborting due to 57 previous errors; 11 warnings emitted\u001b[0m\n"}
